# -*- coding: utf-8 -*-
"""Untitled13.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1Esvo-S8Jss96n7jR7bgrB4jA6UwlbrNf
"""

from pathlib import Path
import pandas as pd
import os
csv_file = "/content/transcripts (2).csv"
df = pd.read_csv(csv_file)
i = 0
split_list = []
path_list = []
absolute_path_list = []
root_dir = "/content/drive/MyDrive/audio/"
while(i < 441):
  paths = df.loc[i, "path"]
  paths = root_dir + str(paths)
  paths = paths.replace("/ ", "/")
  absolute_path_list.append(paths)
  i = i + 1
print(absolute_path_list)

import scipy
import csv
from scipy.io import wavfile
duration_list = []
i = 0
#using path list to iterate through audio folder in correct order
while(i < 441):
  file_name = absolute_path_list[i]
  if(os.path.isfile(file_name)):
    sample_rate, data = wavfile.read(file_name)
    print(file_name)
  elif not(os.path.isfile(file_name)):
      file_name = file_name.replace(".wav", " .wav")
      print(file_name)
      if(os.path.isfile(file_name)):
        sample_rate, data = wavfile.read(file_name)
      elif (os.path.isfile(file_name.replace(" .wav", "  .wav"))):
        sample_rate, data = wavfile.read(file_name)
      else:
        file_name = file_name.replace(" .wav", "   .wav")
        sample_rate, data = wavfile.read(file_name)
        print(file_name)
  len_data = len(data)  # holds length of the numpy array
  t = len_data / sample_rate  # returns duration but in floats
  duration_list.append(round(t, 3))
  i = i + 1
print(duration_list)

import pandas as pd
df["duration"] = duration_list
df.to_csv(file_name, index=False)



import csv

import json

import pandas as pd

# Path to your CSV file
csv_file = '/content/transcripts (2).csv'
root_dir = "content/drive/audio/"


# Function to format each row as JSON with curly braces


# Read CSV file and format each row
with open(output_file, 'w', encoding='utf-8') as out_file:
  i = 0
  out_file.write("[")
  while (i < 441):
    audio_path = df.loc[i, "path"]
    audio_path = str(audio_path)
    duration = float(df.loc[i, "duration"])
    transcript = str(df.loc[i, " sentence "])
    metadata = {
      "audio_filepath": root_dir.rstrip(" ") + audio_path.lstrip(" "),
      "duration": duration,
      "text": transcript}
    json.dump(metadata, out_file)
    out_file.write(",")
    out_file.write('\n')
    i = i + 1

  out_file.write("]")
print(f"Formatted JSON data has been saved to {output_file}")

import json

with open('formatted_output.json') as f_in, open('output3.json', 'w') as f_out:
    data = json.load(f_in)
    for obj in data:
        json.dump(obj, f_out)
        f_out.write(',\n')

import os
import random
import json


def split_text_file(input_file, output_dir, train_ratio=0.8, val_ratio=0.1, test_ratio=0.1):
    # Create output directory if it doesn't exist
    os.makedirs(output_dir, exist_ok=True)

    # Read lines from input file
    with open(input_file, 'r', encoding='utf-8') as f:
        lines = f.readlines()

    total_lines = len(lines)
    indices = list(range(total_lines))
    random.shuffle(indices)

    train_split = int(train_ratio * total_lines)
    val_split = int((train_ratio + val_ratio) * total_lines)

    train_indices = indices[:train_split]
    val_indices = indices[train_split:val_split]
    test_indices = indices[val_split:]

    def write_lines(output_file, indices):
        with open(os.path.join(output_dir, output_file), 'w', encoding='utf-8') as f:
            for idx in indices:
              f.write("")

    write_lines('training.json', train_indices)
    write_lines('validation.json', val_indices)
    write_lines('test.json', test_indices)

# Example usage:
input_file = '/content/formatted_output (3).json'  # Replace with your text file path
output_directory = 'transcripts_output'   # Replace with desired output folder path

split_text_file(input_file, output_directory)